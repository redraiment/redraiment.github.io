<div title="2049 不容易系列之(4)——考新郎" class="article-content">
<div class="sign">2008-06-11 20:04</div>
<h1>问题描述</h1>
<h2>Problem Description</h2>
<img src="resources/figure/hdu/2049-1.gif" align="right" />
<p>国庆期间,省城HZ刚刚举行了一场盛大的集体婚礼,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做"考新郎",具体的操作是这样的:</p>
<p>首先,给每位新娘打扮得几乎一模一样,并盖上大大的红盖头随机坐成一排;</p>
<p>然后,让各位新郎寻找自己的新娘.每人只准找一个,并且不允许多人找一个.</p>
<p>最后,揭开盖头,如果找错了对象就要当众跪搓衣板...</p>
<p>看来做新郎也不是容易的事情...</p>
<p>假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能.</p>
<h2>Input</h2>
<p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1&lt;M&lt;=N&lt;=20)。</p>
<h2>Output</h2>
<p>对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。</p>
<h2>Sample Input</h2>
<pre>2
2 2
3 2</pre>
<h2>Sample Output</h2>
<pre>1
3</pre>
<h1>问题分析</h1>
<h2>Problem Analyse</h2>
<p>递推题</p>
<h2>Algorithm Analyse</h2>
<p>依然是错排问题，方法见<span class="tab-href" title="2048.html">2048</span>题。但这里还要从N个新郎中找出M个冤大头。HOHO~</p>
<p>方法就不用多讲了，就是求组合C<sup>m</sup><sub>n</sub>。</p>
<h1>算法实现</h1>
<p>先求出组合数在乘以错排结果。不然做乘法运算可能会在中间过程中就造成数据溢出。而且组合的规律告诉我们，这里做除法运算不会造成精度丢失情况。</p>
<h1>参考源码</h1>
<pre><code data-language="c">#include &lt;stdio.h&gt;

int main(void)
{
  int i, m, n;
  __int64 a[21][2] = {{1,0},{1,0},{2,1},{6,2}};

  for (i = 4; i &lt; 21; i++)
  {
    a[i][0] = i * a[i-1][0];
    a[i][1] = (i-1) * (a[i-1][1] + a[i-2][1]);
  }
  scanf("%d", &i);
  while (i-- && scanf("%d%d", &n, &m))
    printf("%I64d\n", a[n][0]/a[m][0]/a[n-m][0]*a[m][1]);

  return 0;
}</code></pre>
</div>
