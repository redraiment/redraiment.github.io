<div title="2047 阿牛的EOF牛肉串" class="article-content">
<div class="sign">2008-06-11 20:04</div>
<h1>问题描述</h1>
<h2>Problem Description</h2>
<p>今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由"E" "O" "F"三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，"OO"看起来就像发怒的眼睛，效果不好。</p>
<p>你，NEW ACMer,EOF的崇拜者，能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？</p>
<p>PS: 阿牛还有一个小秘密，就是准备把这个刻有 EOF的牛肉干，作为神秘礼物献给杭电五十周年校庆，可以想象，当校长接过这块牛肉干的时候该有多高兴！这里，请允许我代表杭电的ACMer向阿牛表示感谢！</p>
<p>再次感谢！</p>
<h2>Input</h2>
<p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数n组成，(0&lt;n&lt;40)。</p>
<h2>Output</h2>
<p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
<h2>Sample Input</h2>
<pre>1
2</pre>
<h2>Sample Output</h2>
<pre>3
8</pre>
<h1>问题分析</h1>
<h2>Problem Analyse</h2>
<p>递推题</p>
<h2>Algorithm Analyse</h2>
<p>这一题比起其他题稍微高级一点，它需要两路同时进行梯推。</p>
<p>我们每次都在原来合法的字符串的最后面再加一个字符，让它仍然是合法的字符串。</p>
<p>这就会出现最后一个字符是O和不是O两种情况，把末尾是O的字符串的个数保存在D[I][0]里，而不是O的保存在D[I][1]里。</p>
<p>在原来的字符串上再加个O，让它依然合法，则原来的字符串末尾必须不为O，即D[n][0] = D[n-1][1]</p>
<p>而在原来的字符串上再加非O，则它对前面字符串的末尾没有要求，而且它还有E、F两种。因此D[n][1] = 2 * (D[n-1][0] + D[n-1][1])</p>
<p>初始D[1][0] = 1; D[1][1] = 2; </p>
<h1>参考源码</h1>
<pre><code data-language="c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  int i;
  __int64 d[41][2] = {{0,0}, {1, 2}};

  for (i = 2; i &lt; 41; i++)
  {
    d[i][0] = d[i-1][1];
    d[i][1] = 2 * (d[i-1][0] + d[i-1][1]);
  }
  while (scanf("%d", &i) != EOF)
    printf("%I64d\n", d[i][0] + d[i][1]);

  return 0;
}</code></pre>
</div>
