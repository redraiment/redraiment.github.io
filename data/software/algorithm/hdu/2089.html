<div title="2089 不要62" class="article-content">
<div class="sign">2008-06-11 20:04</div>
<h1>问题描述</h1>
<h2>Problem Description</h2>
<p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。</p>
<p>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。</p>
<p>不吉利的数字为所有含有4或62的号码。例如：</p>
<p>62315 73418 88914</p>
<p>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。</p>
<p>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p>
<h2>Input</h2>
<p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p>
<h2>Output</h2>
<p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p>
<h2>Sample Input</h2>
<pre>1 100
0 0</pre>
<h2>Sample Output</h2>
<pre>80</pre>
<h1>问题分析</h1>
<h2>Problem Analyse</h2>
<p>数学题</p>
<h2>Algorithm Analyse</h2>
<p>一旦碰到62或者4，就进位。</p>
<p>比如，循环到了1234，就加1，到了123400，就加100到123500，碰到62000加1000到63000，依次类推即可。</p>
<h1>算法实现</h1>
<p>直接静态申请，可能开不出1000000这么大的数组，用动态申请一个。</p>
<h1>参考源码</h1>
<pre><code data-language="c">#include &lt;stdio.h&gt;

int A(int n)
{
  int i = 1;
  while (n)
  {
    if (n % 10 == 4 || n % 100 == 62)
      return i;
    n /= 10;
    i *= 10;
  }
  return 0;
}

int main(void)
{
  int n, m, i, c, b;
  int *a = new int[1000000];

  a[0] = 0;
  for (c = 0,i = 1; i &lt; 1000000; i += b)
  {
    b = A(i);
    if (!b) c += b = 1;
    for (n = 0; n &lt; b; n++)
      a[i + n] = c;
  }

  while (scanf("%d%d", &n, &m), n + m)
    printf("%d\n", a[m] - a[n-1]);

  return 0;
}</code></pre>
</div>
